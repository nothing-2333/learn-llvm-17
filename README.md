# learn-llvm-17

书: `https://github.com/xiaoweiChen/Learn-LLVM-17`, 《Learn LLVM 17》的非专业个人翻译

随书代码: `https://github.com/PacktPublishing/Learn-LLVM-17`, 看懂后功力大增。

在发现随书代码后放弃重敲一遍，转而注释已有代码。对书中错误做出出勘误。

没章的 build.sh 脚本用于构建项目, read.md 是阅读代码的笔记。

### build.sh 的使用方式（举例）
```bash
cd ./Learn-LLVM-17/Chapter02/calc/
./build.sh 
```

# 为什么用 llvm
GCC在前端与后端的解耦设计上确实存在局限性，这主要体现在其架构的历史包袱和中间表示的耦合性上。以下是具体分析：

1. **架构设计导致耦合性较高**
GCC虽采用前端与后端分离的模块化设计，但其中间表示（IR）的多层次转换增加了耦合性。例如：
• 前端生成的GENERIC或GIMPLE中间表示需进一步转换为RTL（Register Transfer Language），而RTL与后端硬件特性（如寄存器分配、指令选择）紧密相关。这种多阶段转换导致前端和后端共享大量数据结构，难以彻底解耦。

• 后端优化（如指令调度）直接操作RTL，而RTL本身包含与目标架构相关的信息，这使得前端若想支持新语言，必须适配GCC的中间表示层次，而非仅关注语言本身的解析。


2. **添加新语言或目标架构的复杂性**
由于耦合性，GCC扩展性受限：
• 新增前端需兼容GCC的中间表示（如GIMPLE）和后端接口。例如，即便前端生成GIMPLE，仍需处理与后端优化器相关的逻辑（如类型系统与目标架构的映射）。

• 新增后端需适配RTL及后端优化流程，开发成本高。相比之下，LLVM通过统一的LLVM IR实现前后端解耦，后端只需处理IR到机器码的转换，无需关心前端语言特性。


3. **对比LLVM的解耦优势**
LLVM的三段式架构（前端→IR→后端）展现了更好的解耦：
• 中间表示统一性：LLVM IR是唯一的中间层，前端（如Clang）只需生成标准IR，后端（如x86、ARM）基于IR优化并生成代码。

• 工具链灵活性：LLVM允许混合使用不同前端和后端（如GCC前端+LLVM后端通过DragonEgg实现），而GCC因架构限制难以直接整合其他后端。