## TBAA 元数据
围绕着 `createScalarTypeNode` `createStructTypeNode` `getTypeInfo` 三个函数实现了主要逻辑, `CGM.decorateInst` 添加注释, 比较简单就不在一一解释了, 自己跟一跟。重点讲一下 TBAA

### 结构
1. **标识字段（Identity Field）**：用于唯一标识当前类型。
2. **父节点字段（Parent Field）**：指向当前类型的父节点，用于构建类型树。
3. **偏移字段（Offset Field）**：表示当前类型在父类型中的偏移量。

### 示例
```llvm
!0 = !{!"m\83\826\06\00\00\00\00\A2\8Ef\7F\C9:n", !1, i64 0, !1, i64 8}
!1 = !{!"INTEGER", !2, i64 0}
!2 = !{!"Simple tinylang TBAA"}
```

- **`!0`**：表示 `int` 类型，其父节点是 `!2`。
  - !0：定义了一个 TBAA 元数据节点，表示 Person 结构体的第二个字段。
  - !"m\83\826\06\00\00\00\00\A2\8Ef\7F\C9:n"：标识字段的名称。
  - !1：指向字段的类型信息。
  - i64 0：字段在结构体中的偏移量（从结构体的起始位置开始）。
  - !1：再次指向字段的类型信息。
  - i64 8：字段在结构体中的偏移量（从上一个字段的结束位置开始）。
- **`!1`**：
  - !1：定义了一个 TBAA 元数据节点，表示字段的类型信息。
  - !"INTEGER"：字段的类型名称。
  - !2：指向根节点。
  - i64 0：字段在类型中的偏移量。
- **`!2`**：定义了一个 TBAA 根节点，表示整个 TBAA 系统的起点。!"Simple tinylang TBAA"：根节点的名称。

### 应用举例
```c
int foo(int* a, int* b) {
    *a = 42;
    *b = 20;
    return *a;
}
```
生成的 LLVM IR 如下：
```llvm
define i32 @foo(i32* %0, i32* %1) {
  store i32 42, i32* %0, align 4, !tbaa !1
  store i32 20, i32* %1, align 4, !tbaa !1
  %3 = load i32, i32* %0, align 4, !tbaa !1
  ret i32 %3
}
```

- **`load i32, i32* %0, align 4, !tbaa !1`**：表示加载的指针是 `!1` 类型, 以此类推
- **`!tbaa !1`**：表示这些指令使用了 TBAA 元数据。
- 如果编译器确定 `a` 和 `b` 不会别名（即它们指向不同的内存位置），则可以优化掉不必要的 `load` 指令，直接返回 `42`。



